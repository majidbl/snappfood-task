// Code generated by MockGen. DO NOT EDIT.
// Source: store.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	mysqlstore "task/storage/mysqlstore"

	gomock "github.com/golang/mock/gomock"
)

// MockIStore is a mock of IStore interface.
type MockIStore struct {
	ctrl     *gomock.Controller
	recorder *MockIStoreMockRecorder
}

// MockIStoreMockRecorder is the mock recorder for MockIStore.
type MockIStoreMockRecorder struct {
	mock *MockIStore
}

// NewMockIStore creates a new mock instance.
func NewMockIStore(ctrl *gomock.Controller) *MockIStore {
	mock := &MockIStore{ctrl: ctrl}
	mock.recorder = &MockIStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStore) EXPECT() *MockIStoreMockRecorder {
	return m.recorder
}

// Agent mocks base method.
func (m *MockIStore) Agent() mysqlstore.IAgent {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Agent")
	ret0, _ := ret[0].(mysqlstore.IAgent)
	return ret0
}

// Agent indicates an expected call of Agent.
func (mr *MockIStoreMockRecorder) Agent() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Agent", reflect.TypeOf((*MockIStore)(nil).Agent))
}

// DelayReport mocks base method.
func (m *MockIStore) DelayReport() mysqlstore.IDelayReport {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DelayReport")
	ret0, _ := ret[0].(mysqlstore.IDelayReport)
	return ret0
}

// DelayReport indicates an expected call of DelayReport.
func (mr *MockIStoreMockRecorder) DelayReport() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DelayReport", reflect.TypeOf((*MockIStore)(nil).DelayReport))
}

// Order mocks base method.
func (m *MockIStore) Order() mysqlstore.IOrder {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Order")
	ret0, _ := ret[0].(mysqlstore.IOrder)
	return ret0
}

// Order indicates an expected call of Order.
func (mr *MockIStoreMockRecorder) Order() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Order", reflect.TypeOf((*MockIStore)(nil).Order))
}

// Vendor mocks base method.
func (m *MockIStore) Vendor() mysqlstore.IVendor {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Vendor")
	ret0, _ := ret[0].(mysqlstore.IVendor)
	return ret0
}

// Vendor indicates an expected call of Vendor.
func (mr *MockIStoreMockRecorder) Vendor() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Vendor", reflect.TypeOf((*MockIStore)(nil).Vendor))
}

// MockITransaction is a mock of ITransaction interface.
type MockITransaction struct {
	ctrl     *gomock.Controller
	recorder *MockITransactionMockRecorder
}

// MockITransactionMockRecorder is the mock recorder for MockITransaction.
type MockITransactionMockRecorder struct {
	mock *MockITransaction
}

// NewMockITransaction creates a new mock instance.
func NewMockITransaction(ctrl *gomock.Controller) *MockITransaction {
	mock := &MockITransaction{ctrl: ctrl}
	mock.recorder = &MockITransactionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockITransaction) EXPECT() *MockITransactionMockRecorder {
	return m.recorder
}

// Transaction mocks base method.
func (m *MockITransaction) Transaction(ctx context.Context, fn mysqlstore.Fn) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Transaction", ctx, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// Transaction indicates an expected call of Transaction.
func (mr *MockITransactionMockRecorder) Transaction(ctx, fn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Transaction", reflect.TypeOf((*MockITransaction)(nil).Transaction), ctx, fn)
}
